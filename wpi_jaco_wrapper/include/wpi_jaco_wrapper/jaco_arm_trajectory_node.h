/*!
 * \jaco_arm_trajectory_node.h
 * \brief Provides for trajectory execution and gripper control of the JACO arm.
 *
 * jaco_arm_trajectory_node creates a ROS node that provides trajectory execution and gripper 
 * control through the Kinova API, and smooth trajectory following through a velocity controller.
 *
 * \author David Kent, GT - dekent@gatech.edu
 * \author Mitchell Wills, WPI - mwills@wpi.edu
 */

#ifndef JACO_ARM_TRAJECTORY_NODE_H_
#define JACO_ARM_TRAJECTORY_NODE_H_

#include <rclcpp/rclcpp.hpp>

#include "rclcpp_action/rclcpp_action.hpp"
#include <boost/foreach.hpp>
#include <boost/thread/recursive_mutex.hpp>
#include "control_msgs/action/follow_joint_trajectory.hpp"
#include "control_msgs/action/gripper_command.hpp"
#include <ecl/geometry.hpp>
#include <wpi_jaco_msgs/msg/angular_command.hpp>
#include <wpi_jaco_msgs/msg/cartesian_command.hpp>
#include <wpi_jaco_msgs/srv/e_stop.hpp>
#include <wpi_jaco_msgs/srv/get_angular_position.hpp>
#include <wpi_jaco_msgs/srv/get_cartesian_position.hpp>
#include <wpi_jaco_msgs/action/home_arm.hpp>
#include <wpi_jaco_msgs/srv/jaco_fk.hpp>
#include <wpi_jaco_msgs/srv/quaternion_to_euler.hpp>
#include <sensor_msgs/msg/joint_state.hpp>
#include <std_msgs/msg/bool.hpp>
#include <std_srvs/srv/empty.hpp>

#include <wpi_jaco_wrapper/jaco_conversions.h>
#include <wpi_jaco_wrapper/jaco_kinematics.h>

#include <jaco_sdk/Kinova.API.UsbCommandLayerUbuntu.h>

#define NUM_JACO_JOINTS 6

#define LARGE_ACTUATOR_VELOCITY 0.8378 //maximum velocity of large actuator (joints 1-3) (rad/s)
#define SMALL_ACTUATOR_VELOCITY 1.0472 //maximum velocity of small actuator (joints 4-6) (rad/s)
#define TIME_SCALING_FACTOR 1.5 //keep the trajectory at a followable speed

#define DEG_TO_RAD (M_PI/180)
#define RAD_TO_DEG (180/M_PI)

//gains for trajectory follower
#define KP 300.0
#define KV 20.0
#define ERROR_THRESHOLD .03 //threshold in radians for combined joint error to consider motion a success

//gains for finger controller
#define KP_F 7.5
#define KV_F 0.05
#define KI_F 0.1

//control types
#define ANGULAR_CONTROL 1
#define CARTESIAN_CONTROL 2

#define NO_KINOVA_ERROR 1 //no error from Kinova API

namespace jaco
{
using HomeArm = wpi_jaco_msgs::action::HomeArm;
using GoalHandleHomeArm = rclcpp_action::ServerGoalHandle<HomeArm>;

using FollowJointTrajectory = control_msgs::action::FollowJointTrajectory;
using GoalHandleFollowJointTrajectory = rclcpp_action::ServerGoalHandle<FollowJointTrajectory>;

using GripperCommand = control_msgs::action::GripperCommand;
using GoalHandleGripperCommand = rclcpp_action::ServerGoalHandle<GripperCommand>;

/*!
 * \class jacoArmTrajectoryController
 * \brief Provides for trajectory execution and gripper control of the JACO arm.
 *
 * jacoArmTrajectoryController creates a ROS node that provides trajectory execution and gripper 
 * control through the Kinova API, and smooth trajectory following through a velocity controller.
 */
class JacoArmTrajectoryController
{
public:
  /**
   * \brief Constructor
   * @param nh ROS node handle
   * @param pnh ROS private node handle
   */
  JacoArmTrajectoryController(const std::shared_ptr<rclcpp::Node> n);

  /**
   * \brief Destructor
   */
  virtual ~JacoArmTrajectoryController();

  /**
   * \brief Reads joint states from the arm and publishes them as a JointState message
   */
  void update_joint_states();

  /**
   * \brief move the arm to the home position using the Kinova API home call
   * @param goal action goal
   */
  void home_arm(const std::shared_ptr<GoalHandleHomeArm> gh);

  /**
   * \brief Callback for the arm_controller, executes a joint angle trajectory
   * @param goal action goal
   */
  void execute_trajectory(const std::shared_ptr<GoalHandleFollowJointTrajectory> gh);

  /**
   * \brief Callback for the smooth_arm_controller, executes a smoother Cartesian trajectory 
   
   * The trajectory is generated by converting joint angle trajectories to 
   * end effector cartesian trajectories and smoothed automatically by the JACO's
   * Cartesian position controller.
   
   * NOTE: the trajectories must not fall within constraints defined internally
   * on the JACO for singularity avoidance
   * @param goal action goal
   */
  void execute_smooth_trajectory(const std::shared_ptr<GoalHandleFollowJointTrajectory> gh);

  /**
   * \brief Callback for the joint_velocity_controller, executes a smoothed trajectory with velocity control
   *
   * The trajectory is generated by interpolating a set of joint trajectory points and smoothing the corners
   * using an acceleration constraint. The trajectory is then followed by using a velocity controller implemented
   * in this node which sends joint velocity commands to the arm.
   * @param goal action goal
   */
  void execute_joint_trajectory(const std::shared_ptr<GoalHandleFollowJointTrajectory> gh);

  /**
   * \brief Callback for the gripper_server_, executes a gripper command
   * @param goal action goal
   */
  void execute_gripper(const std::shared_ptr<GoalHandleGripperCommand> gh);

  /**
   * \brief Callback for the gripper_server_radian_, executes a gripper command with a goal representing the finger position in radians
   * @param goal action goal
   */
  void execute_gripper_radian(const std::shared_ptr<GoalHandleGripperCommand> gh);

  void joint_trajectory_handle_accepted(const std::shared_ptr<GoalHandleFollowJointTrajectory>gh);
  rclcpp_action::GoalResponse joint_trajectory_handle_goal(const rclcpp_action::GoalUUID &uuid, std::shared_ptr<const FollowJointTrajectory::Goal>goal);
  rclcpp_action::CancelResponse joint_trajectory_handle_cancel(const std::shared_ptr<GoalHandleFollowJointTrajectory>gh);

  void home_arm_handle_accepted(const std::shared_ptr<GoalHandleHomeArm>gh);
  rclcpp_action::GoalResponse home_arm_handle_goal(const rclcpp_action::GoalUUID &uuid, std::shared_ptr<const HomeArm::Goal>goal);
  rclcpp_action::CancelResponse home_arm_handle_cancel(const std::shared_ptr<GoalHandleHomeArm>gh);

  void execute_gripper_handle_accepted(const std::shared_ptr<GoalHandleGripperCommand>gh);
  rclcpp_action::GoalResponse execute_gripper_handle_goal(const rclcpp_action::GoalUUID &uuid, std::shared_ptr<const GripperCommand::Goal>goal);
  rclcpp_action::CancelResponse execute_gripper_handle_cancel(const std::shared_ptr<GoalHandleGripperCommand>gh);

private:
  bool loadParameters(const std::shared_ptr<rclcpp::Node> n);
  /**
   * \brief Callback for sending an angular command to the arm
   * @param msg angular command and info
   */
  void angularCmdCallback(const wpi_jaco_msgs::msg::AngularCommand::SharedPtr msg);

  /**
   * \brief Callback for sending a Cartesian command to the arm
   * @param msg Cartesian command and info
   */
  void cartesianCmdCallback(const wpi_jaco_msgs::msg::CartesianCommand::SharedPtr msg);

  /**
  * \brief Control with finger velocity inputs to reach a given position
  * @param f1 position of finger 1
  * @param f2 position of finger 2
  * @param f3 position of finger 3
  */
  void fingerPositionControl(float f1, float f2, float f3);

  /**
   *\brief Stripped-down angular trajectory point sending to the arm
   *
   * This is designed for trajectory followers, which need a quick response
   * @param point angular trajectory point to send to the arm
   * @param erase if true, clear the trajectory point stack before sending point
   */
  void executeAngularTrajectoryPoint(TrajectoryPoint point, bool erase);

  /**
   * \brief Stripped-down Cartesian trajectory point sending to the arm
   *
   * This is designed for trajectory followers, which need a quick response
   * trajectory followers that need very quick response
   * @param point Cartesian trajectory point to send to the arm
   * @param erase if true, clear the trajectory point stack before sending point
   */
  void executeCartesianTrajectoryPoint(TrajectoryPoint point, bool erase);

  /**
   * \brief Service callback for getting the current joint positions of the arm and fingers
   *
   * This allows other nodes to request the joint positions when needed, rather than listening to the joint_state
   * topic.  The positions are given in radians on [-pi, pi].
   * @param req empty service request
   * @param res service response including joint positions
   * @return true on success
   */
  bool getAngularPosition(
      const std::shared_ptr<rmw_request_id_t> request_header,
      const std::shared_ptr<wpi_jaco_msgs::srv::GetAngularPosition::Request> req,
      std::shared_ptr<wpi_jaco_msgs::srv::GetAngularPosition::Response> res);

  /**
   * \brief Service callback for getting the current Cartesian pose of the end effector
   *
   * This allows other nodes to get the pose which is normally only accessible
   * through the Kinova API
   * @param req empty service request
   * @param res service response including the end effector pose
   * @return true on success
   */
  bool getCartesianPosition(
      const std::shared_ptr<rmw_request_id_t> request_header,
      const std::shared_ptr<wpi_jaco_msgs::srv::GetCartesianPosition::Request> req,
      std::shared_ptr<wpi_jaco_msgs::srv::GetCartesianPosition::Response> res);

  /**
  * \brief Callback for enabling/disabling the software emergency stop
  *
  * @param req service request
  * @param res service response
  * @return true on success
  */
  bool eStopCallback(
      const std::shared_ptr<rmw_request_id_t> request_header,
      const std::shared_ptr<wpi_jaco_msgs::srv::EStop::Request> req,
      std::shared_ptr<wpi_jaco_msgs::srv::EStop::Response> res);

  /**
  * \brief Callback for erasing trajectories currently running on the arm
  *
  * @param req empty service request
  * @param res empty service response
  */
  bool eraseTrajectoriesCallback(
      const std::shared_ptr<rmw_request_id_t> request_header,
      const std::shared_ptr<std_srvs::srv::Empty::Request> req,
      std::shared_ptr<std_srvs::srv::Empty::Response> res);

  /**
   * @brief This function sets the finger positions
   * The new finger position, combined with current joint values are constructed as a trajectory point. sendAdvancedTrajectory() is called in api to complete the motion.
   * @param fingers in degrees from 0 to about 6800
   * @param timeout timeout default 0.0, not used.
   * @param push default true, errase all trajectory before request motion.
   */
  void setFingerPositions(const std::vector<float> &fingers, int timeout, bool push);

  std::shared_ptr<rclcpp::Node> nh;

  // Messages
  rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr joint_state_pub_; //!< publisher for joint states
  rclcpp::Publisher<wpi_jaco_msgs::msg::CartesianCommand>::SharedPtr cartesianCmdPublisher; //!< publisher for Cartesian arm commands
  rclcpp::Publisher<wpi_jaco_msgs::msg::AngularCommand>::SharedPtr angularCmdPublisher; //!< publisher for angular arm commands
  rclcpp::Publisher<std_msgs::msg::Bool>::SharedPtr armHomedPublisher; //!< publisher for when the arm completes a kinova api home arm action
  rclcpp::Subscription<wpi_jaco_msgs::msg::CartesianCommand>::SharedPtr cartesianCmdSubscriber; //!< subscriber for Cartesian arm commands
  rclcpp::Subscription<wpi_jaco_msgs::msg::AngularCommand>::SharedPtr angularCmdSubscriber; //!< subscriber for angular arm commands

  // Services
  // rclcpp::Client<wpi_jaco_msgs::srv::JacoFK>::SharedPtr jaco_fk_client; //!< forward kinematics client
  // rclcpp::Client<wpi_jaco_msgs::srv::GetAngularPosition>::SharedPtr QuaternionToEuler; //!< quaternion to euler (XYZ) conversion client
  rclcpp::Service<wpi_jaco_msgs::srv::GetAngularPosition>::SharedPtr angularPositionServer; //!< service server to get the joint positions
  rclcpp::Service<wpi_jaco_msgs::srv::GetCartesianPosition>::SharedPtr cartesianPositionServer; //!< service server to get end effector pose
  rclcpp::Service<wpi_jaco_msgs::srv::EStop>::SharedPtr eStopServer; //!< service server for software estop and restart
  rclcpp::Service<std_srvs::srv::Empty>::SharedPtr eraseTrajectoriesServer;

  // Actions
  rclcpp_action::Server<FollowJointTrajectory>::SharedPtr trajectory_server_; //!< point-to-point trajectory follower
  rclcpp_action::Server<FollowJointTrajectory>::SharedPtr smooth_trajectory_server_; //!< smooth point-to-point trajectory follower based on Cartesian end effector positions
  rclcpp_action::Server<FollowJointTrajectory>::SharedPtr smooth_joint_trajectory_server_; //!< smooth point-to-point trajectory follower based on joint velocity control
  rclcpp_action::Server<GripperCommand>::SharedPtr gripper_server_; //!< gripper command action server (goal in Kinova API units)
  rclcpp_action::Server<GripperCommand>::SharedPtr gripper_server_radian_; //!< gripper command action server (goal in radians)
  rclcpp_action::Server<wpi_jaco_msgs::action::HomeArm>::SharedPtr home_arm_server_;

  rclcpp_action::Client<GripperCommand>::SharedPtr gripper_client_; //!< gripper command action client, used for sending a converted goal from gripper_server_radian_ to execute on the gripper_server_

  rclcpp::TimerBase::SharedPtr joint_state_timer_; //!< timer for joint state publisher

  std::shared_ptr<JacoConversions> jc;
  std::shared_ptr<JacoKinematics> jk;

  boost::recursive_mutex api_mutex;

  bool eStopEnabled;

  bool arm_initialized;

  // Parameters
  std::string   arm_name_;
  std::string   topic_prefix_;
  double        finger_scale_;
  double        finger_error_threshold_; //threshold in the JACO API's finger position units to consider a finger position reached
  double        max_curvature_;
  double        max_speed_finger_;
  double        gripper_open_;
  double        gripper_closed_;
  double        finger_conv_ratio_;
  int           num_fingers_;
  int           num_joints_;
  bool          kinova_gripper_;

  std::vector<std::string> joint_names;
  std::vector<double>      joint_pos_;
  std::vector<double>      joint_vel_;
  std::vector<double>      joint_eff_;

  unsigned int controlType; //current state of control

  rclcpp::Time last_nonstall_time_;
  std::vector<float> last_nonstall_finger_positions_;
};

}

#endif
